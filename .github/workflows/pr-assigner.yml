name: PR ìë™ í• ë‹¹

on:
  pull_request:
    types: [opened]

jobs:
  assign-reviewers:
    runs-on: ubuntu-latest

    steps:
      - name: ì½”ë“œ ì²´í¬ì•„ì›ƒ
        uses: actions/checkout@v4

      - name: PR ìë™ í• ë‹¹
        uses: actions/github-script@v6
        with:
          script: |
            const prAuthor = context.payload.pull_request.user.login;
            const branchName = context.payload.pull_request.head.ref;

            // íŒ€ì› ëª©ë¡ (ì‹¤ì œ GitHub ì‚¬ìš©ìëª…ìœ¼ë¡œ ë³€ê²½ í•„ìš”)
            const teamMembers = [
              'adampark',  // ì‹¤ì œ GitHub ì‚¬ìš©ìëª…ìœ¼ë¡œ ë³€ê²½
              // 'team-member2',
              // 'team-member3'
            ];

            // PR ì‘ì„±ìë¥¼ ì œì™¸í•œ ë¦¬ë·°ì–´ ì„ íƒ
            const availableReviewers = teamMembers.filter(member => member !== prAuthor);

            // ë¸Œëœì¹˜ëª… ê¸°ë°˜ í• ë‹¹ ë¡œì§
            let assignees = [];
            let reviewers = [];

            if (branchName.startsWith('feature/')) {
              // ê¸°ëŠ¥ ê°œë°œ: ëœë¤ ë¦¬ë·°ì–´ 1ëª…
              if (availableReviewers.length > 0) {
                const randomReviewer = availableReviewers[Math.floor(Math.random() * availableReviewers.length)];
                reviewers.push(randomReviewer);
              }
            } else if (branchName.startsWith('bugfix/') || branchName.startsWith('hotfix/')) {
              // ë²„ê·¸/í•«í”½ìŠ¤: ëª¨ë“  íŒ€ì› ë¦¬ë·°
              reviewers = availableReviewers;
            } else if (branchName.startsWith('refactor/')) {
              // ë¦¬íŒ©í† ë§: ì‹œë‹ˆì–´ ê°œë°œì ìœ„ì£¼
              reviewers = availableReviewers.slice(0, 1); // ì²« ë²ˆì§¸ íŒ€ì›ì„ ì‹œë‹ˆì–´ë¡œ ê°€ì •
            }

            // í• ë‹¹ì ì„¤ì • (PR ì‘ì„±ìê°€ ì•„ë‹Œ ì²« ë²ˆì§¸ íŒ€ì›)
            if (availableReviewers.length > 0) {
              assignees.push(availableReviewers[0]);
            }

            try {
              // ë¦¬ë·°ì–´ í• ë‹¹
              if (reviewers.length > 0) {
                await github.rest.pulls.requestReviewers({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  reviewers: reviewers
                });
                console.log(`ë¦¬ë·°ì–´ í• ë‹¹ë¨: ${reviewers.join(', ')}`);
              }
              
              // ë‹´ë‹¹ì í• ë‹¹
              if (assignees.length > 0) {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  assignees: assignees
                });
                console.log(`ë‹´ë‹¹ì í• ë‹¹ë¨: ${assignees.join(', ')}`);
              }
              
              // í• ë‹¹ ê²°ê³¼ ëŒ“ê¸€
              const comment = `
              ## ğŸ¤– ìë™ í• ë‹¹ ì™„ë£Œ
              
              **ë‹´ë‹¹ì**: ${assignees.length > 0 ? assignees.map(a => `@${a}`).join(', ') : 'ì—†ìŒ'}
              **ë¦¬ë·°ì–´**: ${reviewers.length > 0 ? reviewers.map(r => `@${r}`).join(', ') : 'ì—†ìŒ'}
              
              *ë¸Œëœì¹˜ ìœ í˜•: \`${branchName.split('/')[0]}\`*
              `;
              
              await github.rest.issues.createComment({
                issue_number: context.payload.pull_request.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              
            } catch (error) {
              console.error('í• ë‹¹ ì¤‘ ì˜¤ë¥˜:', error);
            }
